# Example

DocumentLab is useful in cases when we have a document available to us only in the form of a static PDF/photo/scanned and we're only able to access the information in the file as a bitmap. This is the case with a lot of communications formats even still today since digitalization and standardization of these things only go so far when we've got countless of different systems doing the same things.

For example,
* Invoices
* Purchase orders
* Annual reports
* Sales reports
* ... So many things. What can you think of?

The common thing across these kind of documents across a wide domain of origins is not "where things are placed on the page" or in "which order things appear" but actually **contextual** information. For example, receiver information on invoices across 99% of invoices can be defined within a manageable set of patterns. DocumentLab will not care if you pass in an invoice from sender A, B or C even though they may look entirely different each one of them, we only care about matching distinct patterns common across those documents.

## Image

The following image is used in this example. 

<img src="https://raw.githubusercontent.com/karisigurd4/DocumentLab/master/Documentation/Example1.png" width="70%" />

## Script

Let's assume the data we want to extract from the image above is the following,
* The email in the top row
* The web address in the second row
* The entire contents of the third column
* All dates in the document

We can solve that by defining the following script, note that // is used for comments 

```

// Start by finding the text "Label1" and then moving right until we capture an email
// We're expecting the pattern to include the amount in the middle but we don't care about capturing that one
Label1: 
Text(Label1) Right Amount Right [Email];

// Start by finding any text and capture the WebAddress to the right of it
// Only one row in the image will match this pattern
Label2: 
Text Right [WebAddress];

// Specify a pattern with named captures, result will be a json object 
LastColumn: 
'EmailAddress': [Email] Down 'WebAddress': [WebAddress] Down 'Number': [Number] Down 'Text': [Text];

// Capture any date in the document
Dates: 
Any [Date];

```

The following predicates are valid from the text analysis classifications,
* AmountOrNumber
* Amount
* Date
* Email
* InvoiceNumber
* Letters
* Number
* PageNumber
* Percentage
* Text 
* WebAddress
* Definitions by custom files under *Data\Context* (see: [Custom text type definitions](https://github.com/karisigurd4/DocumentLab/blob/master/Documentation/Configuration.md))
* Custom defined text types configured in *Data\TextTypeDefinitions.json*

## Output

This is the output generated by DocumentLab when the image and script above is applied

```json
{
  "Label1": "email@email.com",
  "Label2": "http://www.website.com/",
  "LastColumn": {
    "EmailAddress": "email@email.com",
    "WebAddress": "http://www.website.com/",
    "Number": "50",
    "Text": "Example"
  },
  "Dates": [
    "2018-01-01",
    "2019-12-26"
  ]
}
```

## Using the library
Given that we're using the [script](https://github.com/karisigurd4/DocumentLab/blob/master/Documentation/Examples.md#using-the-library#script) and have the [output](https://github.com/karisigurd4/DocumentLab/blob/master/Documentation/Examples.md#using-the-library#output) structure specified above. If you want to map the result to a C# object you can define a corresponding one such as the following

```C#
public class LastColumn 
{
  public string Email { get; set; }
  public string WebAddress { get; set; }
  public int Number { get; set; }
  public string Text { get; set; }
}

public class Result 
{
  public string Label1 { get; set; }
  public string Label2 { get; set; }
  public LastColumn LastColumn { get; set; }
  public DateTime[] Dates { get; set; }
}
```

We can then map the output json result to a C# object with a Json converter, for instance the following using Newtonsoft,

```C#

string imagePath = "Examples\Example1.png";

string script = @"

  // Start by finding the text "Label1" and then moving right until we capture an email 
  // We're expecting the pattern to include the amount in the middle but we don't care about capturing that one
  Label1: 
  Text(Label1) Right Amount Right [Email];

  // Start by finding any text and capture the WebAddress to the right of it
  // Only one row in the image will match this pattern
  Label2: 
  Text Right [WebAddress];

  // Specify a pattern with named captures, result will be a json object  
  LastColumn: 
  'EmailAddress': [Email] Down 'WebAddress': [WebAddress] Down 'Number': [Number] Down 'Text': [Text];

  // Capture any date in the document
  Dates: 
  Any [Date];

";

// Instantiate DocumentLab 
var documentLab = new DocumentInterpreter();

// Pass in our script as a string and the document image as a bitmap, we can use System.Drawing to handle file loading
var interpretedJsonResult = documentLab.InterpretToJson(script, (Bitmap)Image.FromFile(imagePath));

/*
Write our result to console out, we'll see the following

{
  "Label1": "email@email.com",
  "Label2": "http://www.website.com/",
  "LastColumn": {
    "EmailAddress": "email@email.com",
    "WebAddress": "http://www.website.com/",
    "Number": "50",
    "Text": "Example"
  },
  "Dates": [
    "2018-01-01",
    "2019-12-26"
  ]
}
*/
Console.WriteLine(interpreterJsonResult);

// Convert the json string to defined object structure
var asObject = JsonConvert.DeserializeObject<Result>(interpretedJsonResult)

// ... We've now got an object to work with!

```

The base example without comments or example console out part has only three statements in it that actually perform any operation, that is, instantiation of DocumentLab, calling the InterpretToJson and the DeserializeObject method calls. 
